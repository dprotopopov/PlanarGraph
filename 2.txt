В пронрамме все шаги прокоментированны, а за счёт объектной модели код довольно просто читается

В данном случае було реализованно 2 алгоритма

Гамма алгоритм:
Удаляются все листья
Удаляются промежуточные точки
Исходный граф разбивается на связанные подграфы к которым собственно и применяется алгоритм

Создаём очередь подграфов - в начале в ней только один подграф
Выбираем из очереди один подграф
Если мы ещё не начинали рисовать то берем любой цикл и дважду помещаем его в множество граней
Если мы продолжаем рисовать внутри уже нарисованного графа, то берём один любой цикл и помещаем его один раз в множество граней
Если цикла нет - то даннай граф -дерево и считаем что всё проверено
Добавлем последнюю добавленную грань в множество граней к уже построенному графу
Разбиваем текущий граф на 2 графа - граф проходящий только через точки построенного графа и граф проходящий через точки не принадлежащие построенному графу
граф проходящий через точки не принадлежащие построенному графу разбиваем на связанные подграфы и отправляем в очередь для дальнейшего рассмотрения
Берём все пути из множества точек построенного графа в множество точек построенного графа - эти пути прохлдят как через сам построенный граф, так и через точки не принадлежащие построенному графу.
И только теперь применяем к этим путям собственно то, что Вы присылали
Последовательно наращиваем построенный граф путями из данного множества, каждый раз пересматривая это множество разбивая пути на подпути если путь пересекается с уже построенным графом и удаляя дубликаты от этого разбиения
То есть каждый путь должен двумя концами лежать на одной грани - если найден путь не удовлетворяющий такому условию, то весь граф не планарен
Барём любой путь с минимальным количеством граней к которым он примыкает и любая грань к которой примыкает путь.
Разбиваем грань на две грани и добавляем их в множество граней, а исходную грань исключаем из множества граней
Добавляем этот путь к построенному графу
и повторяем пока множество оставшихся путей не пусто - то есть опять разбиваем их построенным графом и т.д.

Переходим к следубщему подграфу из очереди и повторяем

Для 2-го алгоритма собственно всё как описано
Удаляются все листья
Удаляются промежуточные точки
Исходный граф разбивается на связанные подграфы к которым собственно и применяется алгоритм

Берём множество всех циклов
Ограничиваем его только простыми циклами
Ограничеваем его только тау-циклами
Каждому циклу ставим в соответствие двоичный вектор (то есть берём все пары соседних точек в цикле, рассматриваем эту пару как сегмент - ищем по какому индексу в исходном графе находится данный сегмент (поскольку граф - упорядоченное множество сегментов) и в двоичном векторе по данному индексу устанавливаем единицу

Рассматриваем матрицу из полученных двоичных векторов
Требуется проверить существование эквивалентной матрицы содержащей в каждом столбце не более 2-х есдиниц
Приводим матрицу к каноническому виду и удаляем нулевые строки
В результате нужная нам матрица может быть получена только если каждая строка будет прибавлена не более чем одной другой строке
Собственно здесь начинается симплекс-метод
Целевая фунуция - фунция Мак-Лайнв
Берём k векторов и пытаемся их прибавить к другим векторам - находим при какой комбинации целевая функция принимает минимальное значение, запоминаем
Берём другие k векторов и повторяем с учётом запомненого значения
Если перебрали все комбинации из k векторов, то меняем исходный базис на лучшее значение и повторяем симлекс метод, но уже с большим k
Надо где-то остановится если ничего не нашли - я останавливаюсь если найденное значение целевой фунуции не улучшилось
Если целевая функция не ноль то граф не планарен


