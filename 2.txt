Нашел CUDAfy.NET – исправил...теперь ошибка "Error while trying to run project: Cannot start debugging. The assembly to be debugged was built with a platform incompatible with the current system". Как я понял несовместимость с платформой. Предварительно пакеты cuda ставить нужно? Я тестирую на другом компьютере.	
Вообще-то я сам не очень большой эксперт по CUDAfy - в тех требованиях указано что должна быть платворма NET4.0
Я пробовал компилировать под VS2012 - там не компилировалось , перешёл на VS2013 - всё скомпилировалось
Кроме этого должен быть установлен CUDA SDK - вернее комипилятор доступный в пути вызова


Я сильно не разбирался с CUDAfy - насколько я понял - они разворачивают методы и классы, помеченные аннотацией в сишный код - компилируют его с помощью SDK сохраняют полученный код в своей внутней структуре и при вызове метода отправляют код на исполнение и как-то маршалят доступ к внутренним структурам данных этого кода

Ну у Вас были установлены какие-нибудь дополнительные пакеты для cuda, как устанавливал я в прошлом проекте?	
Я ещё установил собственно CUDAfy с самого сайта чере инсталятор, но в документации написано что в этом нет необходимости, достаточно иметь референс на CUDAfy DLL из пакета nuget. Более того - когда я указал в качестве ссылки DLL не из пакета nuget, а более свежую версию из SDK - это тоже не работало



Суть его в распознавании образов, необходимо реализовать два алгоритма распознавания (когда-то сталкивался с подобной темой, есть много библиотек для распознавания) и сравнить их попиксельно методом эталонов и отсечением (описание этих алгоритмов будут, в них ничего сложного). 
Я знакомл с пакетом Opencv и его оболочкой Emucv.Net
Там уже содержатся соответствующие алогритмы - их просто надо обучать - подавать на вход образцы из разных классов и строить соответствующую модель, позволяющую разделять новый образец в соответствующий класс - собственно почти как в теме искусственного интелекта.
Не думаю, что реализую лучше чем там уже реализовано



На днях нужно будет начать проект на ASP.NET, там сроки не так ограничены и проект в разы легче. Математики почти нет. У Вас будет на него время?	
Пришлите техзадание, чтобы оценить и также не залететь с оценкой трудоёмкости
Просто когда я догаваривался для этого задания я предполагал, что алгоритмы будут такой же сложности как и предыдущий проект - один отдельный алгоритм и всё. А здесь оказалась комплексная система состоящая из кучи определений, теорем и алгоритмов

но и заплатить ту сумму на которую мы договорились, я попросту не могу,  
Мы вобще-то договаривались на 2000р за 2 алгоритма - думаю пара тысяч найдётся, хотя работы там явно значительно больше

Опс - опять нащёл неправильное утверждение - должно быть
Если цикла нет - то даннай граф -дерево то проверяем, что все пути укаладываются в уже построенный граф


В пронрамме все шаги прокоментированны, а за счёт объектной модели код довольно просто читается

В данном случае було реализованно 2 алгоритма

Гамма алгоритм:
Удаляются все листья
Удаляются промежуточные точки
Исходный граф разбивается на связанные подграфы к которым собственно и применяется алгоритм

Создаём очередь подграфов - в начале в ней только один подграф
Выбираем из очереди один подграф
Если мы ещё не начинали рисовать то берем любой цикл и дважду помещаем его в множество граней
Если мы продолжаем рисовать внутри уже нарисованного графа, то берём один любой цикл и помещаем его один раз в множество граней
Если цикла нет - то даннай граф -дерево то проверяем, что все пути укаладываются в уже построенный граф
Добавлем последнюю добавленную грань в множество граней к уже построенному графу
Разбиваем текущий граф на 2 графа - граф проходящий только через точки построенного графа и граф проходящий через точки не принадлежащие построенному графу
граф проходящий через точки не принадлежащие построенному графу разбиваем на связанные подграфы и отправляем в очередь для дальнейшего рассмотрения
Берём все пути из множества точек построенного графа в множество точек построенного графа - эти пути прохлдят как через сам построенный граф, так и через точки не принадлежащие построенному графу.
Рассматривать пути ведущие из множества точек построенного графа в множество точек не принадлежащих построенному графу не нужно, поскольку
либо пара таких путей проходит через разные мосты к связанной компоненте, могут быть там соединены через связанную компоненту, а значит полученный путь уже в множестве рассматриваемых путей
либо этот путь проходит только через единичный мост содиняющий построенный граф с некой связанной компонентой, а единичные мосты нужно удалить из дальнейшей проверки
И только теперь применяем к этим путям собственно то, что Вы присылали
Последовательно наращиваем построенный граф путями из данного множества, каждый раз пересматривая это множество разбивая пути на подпути если путь пересекается с уже построенным графом и удаляя дубликаты от этого разбиения
То есть каждый путь должен двумя концами лежать на одной грани - если найден путь не удовлетворяющий такому условию, то весь граф не планарен
Барём любой путь с минимальным количеством граней к которым он примыкает и любая грань к которой примыкает путь.
Разбиваем грань на две грани и добавляем их в множество граней, а исходную грань исключаем из множества граней
Добавляем этот путь к построенному графу
и повторяем пока множество оставшихся путей не пусто - то есть опять разбиваем их построенным графом и т.д.

Переходим к следубщему подграфу из очереди и повторяем



Новый алгоритм - проверки связанного графа на планарность - но это надо ещё доказывать правильность

Пусть имеется связанный граф 
Разбиваем множество вершин на непересекающиея множества
для каждого множества формируем граф проходящий только через вершины данного множества
каждый полученный граф разбиваем на связанные подграфы
Получаем множество подграфов, каждый из которых является связанным
Очевидно что множества вершин этик связанных подграфов не пересекаются и в тоже время их объединение равно множеству исходного графа (надо привести доказательство)
Нумеруем все эти подграфы
Создаём новый граф следующим образом - добавляем в новый граф путь из вершины i в вершину j если в исходном графе существуют пути из множества вершин i-го подграфа в множество вершин j-го подграфа и проходящие только через эти множества
Очевидно, что полученный новый граф тоже является связанным (надо привести доказательство)
Очевидно, что полученные новые графы тоже являются связанным (надо привести доказательство)
Необходимое условие планарности:
каждый подграф в отдельности и новый созданный граф планарны
Достаточное условме планарности:
Если каждый подграф, дополнееный всеми путями исходного графа, ведущими из множества вершин подграфа в множество вершин подграфа планарен, то и весь граф планарен - но в этом случае надо доказать сходимость алгоритма - случайно не получится ли после дополнения всеми путями исходный граф? и как-то обработать этот случай


Оптимизация алгоритма достигаеся за счёт начального выбора разбиения множества вершин
И этот алоритм хорошо параллелится - поскольку здесь каждая проверка не зависит от другой



Для 2-го алгоритма собственно всё как описано
Удаляются все листья
Удаляются промежуточные точки
Исходный граф разбивается на связанные подграфы к которым собственно и применяется алгоритм

Берём множество всех циклов
Ограничиваем его только простыми циклами
Ограничеваем его только тау-циклами
Каждому циклу ставим в соответствие двоичный вектор (то есть берём все пары соседних точек в цикле, рассматриваем эту пару как сегмент - ищем по какому индексу в исходном графе находится данный сегмент (поскольку граф - упорядоченное множество сегментов) и в двоичном векторе по данному индексу устанавливаем единицу

Рассматриваем матрицу из полученных двоичных векторов
Требуется проверить существование эквивалентной матрицы содержащей в каждом столбце не более 2-х есдиниц
Приводим матрицу к каноническому виду и удаляем нулевые строки
В результате нужная нам матрица может быть получена только если каждая строка будет прибавлена не более чем одной другой строке
Собственно здесь начинается симплекс-метод
Целевая фунуция - фунция Мак-Лайна
Берём k векторов и пытаемся их прибавить к другим векторам - находим при какой комбинации целевая функция принимает минимальное значение, запоминаем
Берём другие k векторов и повторяем с учётом запомненого значения
Если перебрали все комбинации из k векторов, то меняем исходный базис на лучшее значение и повторяем симлекс метод, но уже с большим k
Надо где-то остановится если ничего не нашли - я останавливаюсь если найденное значение целевой фунуции не улучшилось
Если целевая функция не ноль то граф не планарен

Замечание по 2-му алгоритму:
В присланноых материалах говорится что необходимо получить базис из циклов
Потом приводятся лемма что достаточно взять простые циклы
Потом приводится лемма что достаточно взять тау-циклы

С техничесой точки зрения проверять, что цикл является простым и тау-циклом нет необходимости, поскольку там не приведён алгорим позволяющий проверить , что цикл является тау-циклом за количество операций меньшее чем приведение матрицы к каноническому виду. Поэтому если действительно надо сделать хорошую реализацию, то либо надо закоментировать проверки циклов на простоту и что они являются тау-циклами, либо предложить алгорит быстрой проверки, что цикл является тау-циклом



Также нужно пересмотреть оплату за проделанную Вами работу.	- На оплату я уже не рассчитываю - сложность оказалась значительно больше чем я предполагал изначально - делал исключительно из личного интереса

Неоптимальность данных реализаций ешё заключается в том, что в начале для графа, для всех последующих операций, я строю множество всех непересекающихся путей соединяющих любые две точкм
Потом это множество использую при поиске циклов, проверке циклов на простоту, на тау-цикл и т.д.
Для подграфа это множество просто пересчитывается из родительского

Скажем прямо - если надо будет Вам давать пояснения по математической части алгоритмов и Вы ранее не читали и не обдумывали, то что Вы прислали, то за один день Вы не сможете выучить всё и дать пояснения

